{"version":3,"sources":["getSymplexTables.js","App.js","index.js"],"names":["nextState","state","minDelta","minDeltaIndex","j","d","i","c","xp","a","tetaValues","minTeta","Number","POSITIVE_INFINITY","minTetaIndex","push","b","l","k","teta","number","values","newState","JSON","parse","stringify","z","initialStateTemplate","App","useState","states","setStates","aInput","type","min","id","step","defaultValue","bInput","cInput","resourceLabels","finalMessage","length","x","finalState","toFixed","rowSpan","colSpan","map","onClick","document","getElementById","valueAsNumber","initialState","result","getSymplexStates","className","dangerouslySetInnerHTML","__html","index","el","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.f631593a.chunk.js","sourcesContent":["\r\n// Експортуємо основну функцію з файлу\r\n// Ця функція приймає шаблон початкового стану\r\nexport default function getSymplexStates(initialState) {\r\n  // Створюємо пустий результуючий масив\r\n  let result = [];\r\n\r\n  // Заходимо у цикл, що перебирає змінну state ініціалізуючи її початковим станов\r\n  // Цикл працює допоки state не рівне null \r\n  // У кінці кожної ітерації state замінюється на nextState(state)\r\n  // На кожній ітерації ми додаємо стан до масиву результатів \r\n  for(let state = initialState; state != null; state = nextState(state)) {\r\n    result.push(state);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Функція, що заповнює вектори D і Teta у стані-аргументі \r\n// і повертає наступний, якщо поточний не є оптимальним розв'язанням\r\nfunction nextState(state) {\r\n\r\n  // Створюємо змінні для мінімального значення дельти і індексу цього значення\r\n  let minDelta = 0, minDeltaIndex = -1;\r\n\r\n  // Ітеруємося по стовпцям таблиці\r\n  for(let j = 0; j < 6; ++j) {\r\n    // Ініціалізуємо значення дельта для j-го стовпця\r\n    state.d[j] = 0;\r\n\r\n    // Цей цикл додає перемноження векторів В і Рj \r\n    // до значення дельта для j-го стовпця\r\n    for(let i = 0; i < 3; ++i) {\r\n      state.d[j] += state.c[state.xp[i]]*state.a[i][j];\r\n    }\r\n    // Віднімаємо значення Сj\r\n    state.d[j] -= state.c[j];\r\n\r\n    // Якщо вирахуване значення дельти менше за зафіксований мінімум\r\n    // То фіксуємо новий мінімум та його індекс\r\n    if(state.d[j] < minDelta) {\r\n      minDelta = state.d[j];\r\n      minDeltaIndex = j;\r\n    }\r\n  }\r\n\r\n  // Якщо ми не знайшли дельту меншу за 0\r\n  // То дана таблиця є оптимальною і наступної немає\r\n  if(minDeltaIndex === -1) {\r\n    return null\r\n  }\r\n  \r\n  // Ініціюємо значення масиву значень масиву тет\r\n  const tetaValues = [];\r\n  // Ініціюємо значення мінімального тета та його індексу\r\n  let minTeta = Number.POSITIVE_INFINITY, minTetaIndex = -1;\r\n  \r\n  for(let i = 0; i < 3; ++i) {\r\n    // Вираховуємо значення тета для i-го стовпця і\r\n    // minDelataIndex = k-го стовпця\r\n    tetaValues.push(state.b[i] / state.a[i][minDeltaIndex]);\r\n\r\n    // Якщо значення тета для i-го стовця меньше за зафіксоване\r\n    // То фіксуємо мінімальне значення і його індекс\r\n    if(tetaValues[i] < minTeta && tetaValues[i] >= 0) {\r\n      minTeta = tetaValues[i];\r\n      minTetaIndex = i;\r\n    }\r\n  }  \r\n\r\n  // l - індекс ведучого рядка\r\n  const l = minTetaIndex;\r\n  // k - індекс ведучого стовпця\r\n  const k = minDeltaIndex;\r\n\r\n  // Переносимо значення тета для поточного стану\r\n  state.teta = {\r\n    number: k,\r\n    values: tetaValues\r\n  }\r\n\r\n  // Копіюємо поточний стан у змінну newState\r\n  const newState = JSON.parse(JSON.stringify(state));\r\n\r\n  // Об'являємо нові змінні для більш зручного \r\n  // доступу до властивойтей об'єкту newState\r\n  const {z, d, b, a} = newState;\r\n\r\n  // Видаляємо значення тета для нового стану\r\n  newState.teta = null;\r\n  // Виводимо попередній вектор з басису і вводимо новий\r\n  newState.xp[l] = k;\r\n  // Надалі ми робиро перетворення Жордана\r\n  // Для значення цільової функції\r\n  newState.z = z - (b[l]*d[k])/a[l][k];\r\n  // Для значень дельта\r\n  for(let j = 0; j < 6; ++j) {\r\n    newState.d[j] = d[j] -(a[l][j]*d[k])/a[l][k];\r\n  }\r\n  \r\n  for(let i = 0; i < 3; ++i) {\r\n    // Для значень В\r\n    newState.b[i] = i === l \r\n      ? b[l]/a[l][k] \r\n      : b[i] - (b[l]*a[i][k])/a[l][k];\r\n    // Для значень А\r\n    for(let j = 0; j < 6; ++j) {\r\n      newState.a[i][j] = i === l\r\n                ? a[l][j]/a[l][k]\r\n                : a[i][j] - (a[l][j]*a[i][k])/a[l][k];\r\n    }\r\n  }\r\n  // Повертаємо нову таблицю\r\n  return newState;\r\n}","// Імпортуємо React для правильної її роботи у нашому прокті\nimport React, {useState} from \"react\";\n// Щоб не загромаждувати усе, ми винесли логіку симплекс методу в окрему функцію в окремому файлі, котрий імпортуємо\nimport getSymplexStates from \"./getSymplexTables\";\n\n\n// Готуємо шаблон для початкового стану рішення задачі. Стан (англ. state) - дані для однієї симплекс - таблиці\nconst initialStateTemplate = {\n\n  // Матриця коєфіцієнтів нерівностей обмежень. Ліва її частина ще не заповнена, права - виділена під змінні штучного базису\n  a : [\n      [0, 0, 0,   1, 0, 0], \n      [0, 0, 0,   0, 1, 0], \n      [0, 0, 0,   0, 0, 1]\n  ],\n\n  // Вектор В ще не заповнений\n  b : [0, 0, 0],\n\n  // Вектор С (коєфіцієнти цільвої функції).\n  // Ліва його частина будет заповнена пізніше, права - залишиться нулями, щоб штучні змінні не мали впливу на цільову функцію\n  c : [0, 0, 0,   0, 0, 0],\n\n  // Массив, що вказує номера змінних, що входять до базизу (на початку він вказує на штучний базис). Індекси зменшені на 1, бо так зручніше\n  // Через те, що нумерація масивів починається з нуля.\n  xp: [3, 4, 5],\n\n  // Початкове значення цільової функції. Воно дорівнює 0, бо до базису спочатку входять лише штучні змінні\n  z : 0,\n\n  // Масиви дельт та тет буде заповлений у функції getSymplexStates\n  d: [],\n\n  teta: null\n}\n\n// React-компонент, що представлений у вигляді функції, що повертає значення котрі треба відобразити\nfunction App() {\n\n  // Об'являємо масив станів states і отримуємо його поточне значення. Що реактивно змінюється\n  // якщо ми змінюємо його через отриману функція setStates.\n  // Це означає, що при кожному зміненні масиву станів, компонент буде запускатися і промалюватися заново.\n  const [states, setStates] = useState([]);\n\n  // Сворюємо функції створення розмітки для клітинок вводу значень матриці, обмежені, і коефіцієнтів цільової функції відповідно\n  // Зроблено це задля зручності і відсутності дублюючогося коду\n  const aInput = (i, j) => (<input \n                              type=\"number\" \n                              min=\"0\" \n\n                              // У таких `` кавичках - шабланні строки. Вони підставляюсть значення з ${} у строку\n                              // Наприклад `a${i}${j}` при i = 1 та j = 6 буде \"a16\"\n                              id={`a${i}${j}`} \n                              step=\"0.01\"\n                              \n                              // У таких фігурних дужках вставляються не статичні значення, як у HTML\n                              // А динамічні, як у JSX\n                              defaultValue={i+j + 1}\n                            />);\n  const bInput = (i) => (<input \n                              type=\"number\" \n                              min=\"0\" \n                              id={`b${i}`} \n                              step=\"0.01\" \n                              defaultValue={14*(i + 1)} \n                            />);\n  const cInput = (i) => (<input \n                              type=\"number\" \n                              id={`c${i}`} \n                              step=\"0.01\" \n                              defaultValue={i+3}\n                            />);\n\n  // Об'являємо масив підписів строк обмежені                      \n  const resourceLabels = [\n    \"Труд, люд-год.\",\n    \"Органіч. добрива, кг\",\n    \"Биологіч. добрива, мл\"\n  ];\n\n  // Створюємо функцію, що буде запускатися при натисканні кнопки \"Розв'язати\"\n  const startCalculate = () => {\n\n    \n    for(let i = 0; i < 3; ++i) {\n\n      // Збираємо з форм вводу дані до змінної початкового стану. Тут це вектор В і С\n      // getElementById знаходить HTML-документ у документі, після чого \n      // отримуємо його число за допомогою властивості valueAsNumber\n      initialStateTemplate.b[i] = document.getElementById(`b${i}`).valueAsNumber;\n      initialStateTemplate.c[i] = document.getElementById(`c${i}`).valueAsNumber;\n\n      //Збираємо дані до матриці індексів обмежень \n      for(let j = 0; j < 3; ++j) {\n        initialStateTemplate.a[i][j] = document.getElementById(`a${i}${j}`).valueAsNumber;\n      }\n    }\n\n    // Встановлюємо масив станів. Після цього компонент App автоматично перемальовується\n    setStates(getSymplexStates(initialStateTemplate));\n  };\n\n  // Готуємо шаблон фінального повідомлення\n  let finalMessage = \"\";\n\n  if(states.length > 0) {\n\n    // Створюємо масив фінальних значень змінних з початковими значеннями 0    \n    const x = [0, 0, 0];\n    \n    // Отримуємо останню симплекс-таблицю\n    const finalState = states[states.length - 1];\n\n    // Проходимося по масиву номерів базисних змінних останньої симплекс таблиці\n    for(let i = 0; i < 3; ++i) {\n      // Якщо ми у цьому базисі знаходимо не штучні змінні, то встановлюємо іх значення у масиві х\n      if(finalState.xp[i] < 3) \n        x[finalState.xp[i]] = finalState.b[i];\n    }\n\n    // Встановлюємо фінальне повідомлення\n    finalMessage = `Оптимальним рішенням будет засіяти ${x[0].toFixed(2)} м<sup>2</sup> айстер, ${x[1].toFixed(2)} м<sup>2</sup> жоржин та ${x[2].toFixed(2)} м<sup>2</sup> троянд.\n    Усі симплекс таблиці приведені нижче:`;\n  }\n\n  // Тут ми повертаємо увесь JSX код.\n  // Зазвичай він відповідає HTML кодові, тому коментувати будемо лише окремі моменти\n  return (\n  <>\n\n  <h3>Уведіть свої дані у таблицю нижче і натисніть \"Розрахувати\"</h3>\n\n  <table>\n    <thead>\n      <tr>\n        <td rowSpan=\"2\">Ресурси</td>\n        <td colSpan=\"3\">Витрати на м<sup>2</sup> посівів</td>\n        <td rowSpan=\"2\">Запас</td>\n      </tr>\n      <tr>\n        <td>Айстри</td>\n        <td>Жоржини</td>\n        <td>Троянди</td>\n      </tr>\n    </thead>\n    <tbody>\n      {/* Коментарі тут пишуться так, а не через \"//\", як у джаваскрипт  */}\n      \n      {/* Конструкція з фігурних скобок означає, що ми щось динамічно вписуємо\n          Нижче, ми беремо масив і для кожного з його елементів повераємо JSX розмітку\n          Це створено для рендерингу списку однотипних елементів\n          У даному випадку ми так рендеремо строки обмежень  \n      */}\n      { [0, 1, 2].map(i =>\n        <tr >\n          {/* Підпис обмеження */}\n          <td>{resourceLabels[i]}</td>\n          {/* Внутрішній рендер стовпців.\n              Бо матриця А є двомівною, отже вимагає внутрішього циклу \n          */}\n          {[0, 1, 2].map(j =>\n            <td >\n              {/* Елемент Аij*/}\n              {aInput(i, j)}\n            </td>\n          )}\n          {/* Елемент Вi*/}\n          <td>{bInput(i)}</td>\n        </tr>\n      )}\n    <tr>\n      <td>Прибуток з 1 м<sup>2</sup> посівів</td>\n      {/* Елемент Сi*/}\n      {[0, 1, 2].map(i =>\n        <td >\n          {cInput(i)}\n        </td>\n      )}\n      <td></td>\n    </tr>\n    </tbody>\n  </table>\n\n  {/*Тут кнопці \"Розрахувати\" ми визначаємо, що функція початку обчислень\n     буде запускатися при кліці на кнопку через задання аргументу\n     onClick\n  */}\n  <button onClick={startCalculate} >Розрахувати</button>\n\n  {/*className у JSX - аналог class у HTML\n     {} втавляють текст без обробки HTML розвідки, тому ми встановлюємо HTML розмітку напряму\n     щоб адекватно відображати метри квадратні у фінальному повідомленні.\n     У даному випадку немає небезпеки XSS атаки тому це безпечно\n\n  */}\n  <div className=\"finalMessage\" dangerouslySetInnerHTML={{__html: finalMessage}}></div>\n\n  {/*Перебір станів для відображення симплекс таблиць*/}\n  {states.map((state, index) => \n    <div className=\"wrapper\" >\n      <table>\n        <tr>\n          <td rowSpan=\"2\">B</td>\n          <td rowSpan=\"2\">C<sub>баз</sub></td>\n          <td rowSpan=\"2\">X</td>\n          {/*Циклічне відображення значень х*/}\n          {state.c.map((el, index) => \n            <td >{el}</td>\n          )}\n\n          {/*Відображення через && - спосіб умовного відображення у React\n             У даному випадку якщко state.teta інтерпритується як true\n             То виконується друга частина умови і поверає елементи розмітки\n             Інакше - нічого не відображається\n             Цієї частини може не бути, якщо у нас оптимальний розв'язок нам не потрібно вираховувати тету\n          */}\n          { state.teta &&\n            <td rowSpan=\"2\">&Theta;<sub>{state.teta.number + 1}</sub></td>\n          }\n        </tr>\n        <tr>\n          {/*Відображення Р1...Р6*/}\n          {state.c.map((el, index) => \n            <td >P<sub>{index + 1}</sub></td>\n          )}\n        </tr>\n        {/*Відображення основних рядків таблиці*/}\n        {state.b.map((el, i) => \n          <tr >\n            {/*Значення В у рядку*/}\n            <td>{state.b[i].toFixed(2)}</td>\n            {/*Коефіцієнт С іксу в цьому рядку*/}\n            <td>{state.c[state.xp[i]]}</td>\n            {/*Назва іксу у цьому рядку*/}\n            <td>X<sub>{state.xp[i] + 1}</sub></td>\n            {/*Коефіцієнти обмежень матриці А у цьому рядку*/}\n            {state.a[i].map(el => \n              <td >{el.toFixed(2)}</td>\n            )}\n            {/*Умовне відображення значення тета для цього рядку*/}\n            { state.teta &&\n              <td>{state.teta.values[i] >= 0 ? state.teta.values[i].toFixed(2) : \"-\"}</td>\n            }\n          </tr>\n        )}\n        <tr>\n          {/*Значення цільової функції у цій таблиці*/}\n          <td>Z = {state.z.toFixed(2)}</td>\n          <td colSpan=\"2\">&Delta;<sub>k</sub></td>\n          {/*Рядок дельт*/}\n          {state.d.map(el => \n            <td key=\"el\">{el.toFixed(2)}</td>\n          )}\n        </tr>\n    </table>\n  \n   </div>\n  )}\n  \n  </>);\n}\n\nexport default App;\n","// Підключення React\nimport React from 'react';\n// Підключення React для браузеру\nimport ReactDOM from 'react-dom';\n// Підключення стилів. Це робиться у файлі джаваскрипт, бо збірник React \n// (на базі WebPack) усе одно переносить їх у HTML самостійно\nimport './index.css';\n// Підключення основного компоненту\nimport App from './App';\n\n// Відмальовка нашого основного компоненту у елент HTML з id=\"root\"\n// Це единий елемент, що відображається у HTML, тому розглядати окремо HTML не будемо\n// Також не будемо розглядати файл CSS\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}